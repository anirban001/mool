"""Rule builder module."""

import logging
import os
import subprocess

import mool.shared_utils as su
import mool.file_collection as fc
import mool.java_common as jc
import mool.python_common as pc
import mool.rule_handler as rh
import mool.thrift.cc_thrift as cc_thrift
import mool.thrift.java_thrift as java_thrift


FILE_DEP_PREFIX = 'FILE: '
MVN_INCL_DEP_PREFIX = 'MVNI: '
MVN_COMPL_DEP_PREFIX = 'MVNC: '

MAX_LOOP_COUNT = 5000
TRACE_COMMANDS = (os.environ.get('DEBUG_MODE', '') != '')

EXPANDABLE_KEYS = [su.COMPILE_DEPS_KEY, su.DEPS_KEY, su.EXTRACT_IN_ZIP,
                   su.EXTRACT_RESOURCES_DEP_KEY, su.PACKAGE_MODULES_KEY,
                   su.PACKAGE_TESTS_KEY]


class Error(su.Error):
  """Generic error class."""


def _run_commands(command_list):
  """Run the commands generated by the steps."""
  tracer = logging.info if TRACE_COMMANDS else logging.debug
  # This dictionary should be kept inside as global dictionaries are
  # initialized before monkey patching and eventually results in failures.
  # More over, this is very specific to this function only.
  cmd_handler_map = {
      su.CHANGE_CURR_DIR: su.change_dir,
      su.CREATE_ARCHIVE_ALL_CURRDIR: fc.create_archive_all_currdir,
      su.EXPORT_MVN_DEPS: jc.export_mvn_deps,
      su.EXTRACT_ARCHIVE_IN_CURRDIR: fc.extract_archive_in_currdir,
      su.JAVA_LINK_JAR_COMMAND: jc.perform_linking,
      su.JAVA_TESTNG_RUNNER: jc.java_testng_runner,
      su.PERFORM_JAVA_LINK_ALL_CURRDIR: jc.perform_java_linkall_currdir,
      su.PYTHON_COMPILE_ALL_CURRDIR: pc.compile_all,
      su.PYTHON_CREATE_INITIALIZERS: pc.create_initializers,
      su.PYTHON_EXPAND_LIB: pc.expand_lib,
      su.PYTHON_LINK_ALL: pc.perform_linking,
      su.PYTHON_PYLINT_CHECK: pc.run_pylint_checks,
      su.THRIFT_CHECK_GENERATED_SOURCE: cc_thrift.assert_check_services,
      su.THRIFT_COMPILE_GENERATED_JAVA: java_thrift.compile_thrift_generated
  }

  for command in command_list:
    assert command
    tracer('Command: %s', str(command))
    handler = cmd_handler_map.get(command[0], None)
    if handler:
      handler(command[1:])
    else:
      subprocess.check_call(command)


def _split_rule_symbol(rule_symbol):
  """Split rule symbol."""
  rule_parts = rule_symbol.split(su.RULE_SEPARATOR)
  rule_path = su.RULE_SEPARATOR.join(rule_parts[:-1])
  rule_name = rule_parts[-1:][0]
  return rule_path, rule_name


def _delete_existing_out_files(rule_details):
  """Delete existing out files of a rule before we start building it."""
  def _remove_file(file_path):
    """Remove if a file exists."""
    if su.path_exists(file_path):
      os.remove(file_path)

  out_files = rule_details[su.OUT_KEY]
  if isinstance(out_files, str):
    _remove_file(out_files)
  elif isinstance(out_files, list):
    for out_file in out_files:
      _remove_file(out_file)


class RuleBuilder(object):
  """Traverse rules graph and apply them."""
  def __init__(self, rules_list):
    """Initialize."""
    self._all_rules = '{}{}'.format(su.RULE_SEPARATOR, su.ALL_RULES_KEY)
    self._all_light_rules = '{}{}'.format(
        su.RULE_SEPARATOR, su.ALL_LIGHT_RULES_KEY)
    self._target_prefix = su.BUILD_RULE_PREFIX
    self._rule_handler = rh.RuleHandler()
    self._rules_map = {}
    self._rule_file_cache = {}
    self._build_order = []
    self._load_rules_list_to_map(rules_list)
    self._load_build_order()
    self._load_all_recursive_deps()

  def _expand_symbol(self, item, path):
    """Rule symbol expansion routine."""
    if item.startswith(su.RULE_SEPARATOR):
      return '{}{}'.format(path, item)
    if item.startswith(self._target_prefix):
      return item
    assert False

  def _expand_symbols_in_key(self, rule_details, rule_path, key):
    """Expand symbols in a specified key."""
    rule_details[key] = sorted(
        [self._expand_symbol(x, rule_path) for x in rule_details.get(key, [])])

  def _get_rule_file(self, rule_symbol):
    """Get rule file from rule symbol."""
    assert rule_symbol.startswith(self._target_prefix)
    rule_parts = rule_symbol.split(su.RULE_SEPARATOR)
    assert all([r for r in rule_parts])
    assert len(rule_parts) >= 3
    rule_parts[0] = su.BUILD_ROOT
    rule_parts[-1] = su.BUILD_FILE_NAME
    return os.sep.join(rule_parts)

  def _load_file_cache(self, rule_file):
    """Load file contents from file cache."""
    if rule_file not in self._rule_file_cache:
      # Optimizing run-time error message for common error case.
      if (not su.TEST_MODE_EXECUTION) and (not su.path_exists(rule_file)):
        raise su.Error('Missing rule file: ' + rule_file)
      self._rule_file_cache[rule_file] = su.read_build_file(rule_file)
    return self._rule_file_cache[rule_file]

  def _get_rule_details(self, rule_path, rule_name, rule_file, rule_symbol):
    """Load rule details from symbol."""
    assert rule_symbol.startswith(self._target_prefix)
    # Discourage all upper case build rules to avoid conflict with
    # keyword 'ALL'.
    assert rule_symbol != rule_symbol.upper()
    if rule_name not in self._load_file_cache(rule_file):
      raise su.Error('Rule "{}" does not exist in {}'
                     .format(rule_name, rule_file))
    rule_details = self._load_file_cache(rule_file)[rule_name]
    assert su.PATH_KEY not in rule_details
    rule_details[su.PATH_KEY] = rule_path
    assert su.NAME_KEY not in rule_details
    rule_details[su.NAME_KEY] = rule_name
    for key in EXPANDABLE_KEYS:
      self._expand_symbols_in_key(rule_details, rule_path, key)
    if su.TYPE_KEY not in rule_details:
      raise su.Error('Rule "{}" missing rule_type in {}'.format(
          rule_name, rule_file))
    if su.RELEASE_PACKAGE_TYPE == rule_details[su.TYPE_KEY]:
      rule_details[su.DEPS_KEY].extend(rule_details[su.PACKAGE_MODULES_KEY])
      rule_details[su.DEPS_KEY].extend(rule_details[su.PACKAGE_TESTS_KEY])
    if su.JAVA_TEST_TYPE == rule_details[su.TYPE_KEY]:
      rule_details[su.DEPS_KEY].extend(
          rule_details.get(su.EXTRACT_RESOURCES_DEP_KEY, []))
    # The list of "all dependencies" must be computed automatically. There are
    # no realistic known scenarios where this list should be specified in the
    # BLD specifications file.
    rule_details[su.ALL_DEPS_KEY] = []
    rule_details[su.ALL_DEP_PATHS_KEY] = []
    dir_name = os.path.dirname(rule_file)
    su.check_dirname(dir_name)
    rule_details[su.DIR_ROOT_KEY] = dir_name
    rule_details[su.SYMBOL_KEY] = rule_symbol
    rule_details[su.RULE_FILE_PATH] = rule_file
    return rule_details

  def _load_rules_list_to_map(self, rules_list):
    """Load rules from list to map."""
    active_list = rules_list[:]
    iters = 0
    while active_list:
      rule_symbol = active_list[0]
      active_list = active_list[1:]
      if rule_symbol in self._rules_map:
        continue
      iters += 1
      assert iters <= MAX_LOOP_COUNT
      rule_path, rule_name = _split_rule_symbol(rule_symbol)
      rule_file = self._get_rule_file(rule_symbol)
      self._load_file_cache(rule_file)
      if rule_symbol.endswith(self._all_rules):
        active_list.extend(
            ['{}{}{}'.format(rule_path, su.RULE_SEPARATOR, r)
             for r in self._rule_file_cache[rule_file].keys()])
      elif rule_symbol.endswith(self._all_light_rules):
        light_rules_list = [
            l for l in self._rule_file_cache[rule_file]
            if self._rule_file_cache[rule_file][l].get(
                su.RULE_WEIGHT_KEY, None) is None]
        active_list.extend(['{}{}{}'.format(rule_path, su.RULE_SEPARATOR, r)
                            for r in light_rules_list])
      else:
        rule_details = self._get_rule_details(
            rule_path, rule_name, rule_file, rule_symbol)
        self._rules_map[rule_symbol] = rule_details
        active_list.extend(rule_details[su.DEPS_KEY])
        active_list.extend(rule_details[su.COMPILE_DEPS_KEY])

  def _check_test_dependency(self, rule_details):
    """A non test rule shouldn't have any test dependency."""
    # Test commands key is only set iff the rule is a test rule.
    if any([self._rule_handler.rule_test(rule_details),
            rule_details[su.TYPE_KEY] == su.RELEASE_PACKAGE_TYPE]):
      return
    depends_on = []
    depends_on.extend(rule_details[su.DEPS_KEY])
    depends_on.extend(rule_details[su.COMPILE_DEPS_KEY])
    for rule in depends_on:
      if self._rule_handler.rule_test(self._rules_map[rule]):
        raise su.Error('Non test rule {} cannot depend on test rule {}'.format(
                       rule_details[su.SYMBOL_KEY], rule))

  def _load_build_order(self):
    """Load build order from rules map."""
    # Build order is a list of list of rule symbols. Every first order list
    # is a list of rule symbols that can be built in parallel.
    active_set = set(self._rules_map.keys())
    built_set = set()
    iters = 0
    while active_set:
      iters += 1
      assert iters <= MAX_LOOP_COUNT
      ready_set = set()
      for rule_symbol in active_set:
        deps = self._rules_map[rule_symbol][su.DEPS_KEY][:]
        deps.extend(self._rules_map[rule_symbol][su.COMPILE_DEPS_KEY])
        if all([s in built_set for s in deps]):
          ready_set.add(rule_symbol)
      assert ready_set
      self._build_order.append(sorted(list(ready_set)))
      built_set.update(ready_set)
      active_set = [s for s in active_set if s not in ready_set]

  def _load_all_recursive_deps(self):
    """Load all recursive dependencies for build optimization."""
    for build_group in self._build_order:
      for rule_symbol in build_group:
        rule_details = self._rules_map[rule_symbol]
        all_deps = [rule_symbol]
        for dep_rule_symbol in rule_details[su.DEPS_KEY]:
          dep_rule_details = self._rules_map[dep_rule_symbol]
          include_recursively = (
              self._rule_handler.rule_include_deps_recursively(
                  dep_rule_details))
          if include_recursively:
            all_deps.extend(dep_rule_details[su.ALL_DEPS_KEY])
          all_deps.append(dep_rule_symbol)
        rule_details[su.ALL_DEPS_KEY] = list(set(all_deps))

  def _build_rule_details(self, rule_symbol, rule_details):
    """Execute build steps from rule detail."""
    rule_hash = su.get_dictionary_hash(rule_details)
    file_list = self._rule_handler.rule_file_list(rule_details)
    if not su.needs_build(rule_details[su.WDIR_KEY], file_list, rule_hash):
      logging.info(' Skipping build for %s', rule_symbol)
      return
    if not su.TEST_MODE_EXECUTION:
      su.cleandir(rule_details[su.WDIR_KEY])
      start_time_milli = su.get_epoch_milliseconds()
    _delete_existing_out_files(rule_details)
    command_list = self._rule_handler.rule_build_commands(rule_details)
    _run_commands(command_list)
    su.save_file_list_cache(rule_details[su.WDIR_KEY], file_list, rule_hash)
    if not su.TEST_MODE_EXECUTION:
      end_time_milli = su.get_epoch_milliseconds()
      logging.info('Time (in seconds): %.2f',
                   (end_time_milli - start_time_milli) / 1000.0)

  def _add_test_instrumentation(self, rule_symbol, rule_details,
                                dependency_dict):
    """Add unit test specific instrumentation."""
    if not su.TEST_MODE_EXECUTION:
      return
    dependency_dict[rule_symbol] = [
        FILE_DEP_PREFIX + self._rules_map[rs][su.OUT_KEY]
        for rs in rule_details[su.COMPILE_DEPS_KEY]]
    dependency_dict[rule_symbol].extend(
        [FILE_DEP_PREFIX + f for f in rule_details[su.ALL_DEP_PATHS_KEY]])
    maven_incl_deps, maven_compile_deps = self._rules_map[rule_symbol].get(
        su.MAVEN_DEPS_KEY, ([], []))
    dependency_dict[rule_symbol].extend(
        [MVN_INCL_DEP_PREFIX + str(d) for d in maven_incl_deps])
    dependency_dict[rule_symbol].extend(
        [MVN_COMPL_DEP_PREFIX + str(d) for d in maven_compile_deps])

  def _build_rule_symbol(self, rule_symbol, run_tests, dependency_dict):
    """Build a symbol assuming all dependencies have been built."""
    logging.info('-----\nBuilding %s', rule_symbol)
    rule_details = self._rules_map[rule_symbol]
    self._rule_handler.rule_setup(rule_details, self._rules_map)
    self._add_test_instrumentation(rule_symbol, rule_details, dependency_dict)
    self._build_rule_details(rule_symbol, rule_details)
    self._check_test_dependency(rule_details)
    if run_tests:
      command_list = self._rule_handler.rule_test(rule_details)
      if command_list:
        logging.info('-----\nRunning test %s', rule_symbol)
        _run_commands(command_list)

  def do_builds(self, run_tests, dependency_dict):
    """Execute the rules."""
    for build_group in self._build_order:
      # Note: Parallelization logic should go here.
      for rule_symbol in build_group:
        self._build_rule_symbol(rule_symbol, run_tests, dependency_dict)
    return 0

  def get_rules_map(self):
    """Returns rules map dictionary."""
    return self._rules_map
