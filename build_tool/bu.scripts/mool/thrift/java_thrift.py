"""Rules for building Java thrift libraries."""
import glob
import logging
import os
import subprocess

import mool.java_common as jc
import mool.shared_utils as su
import mool.thrift.thrift_common as tc


def compile_thrift_generated(params):
  """Compiles java source files generated by thrift."""
  assert 1 == len(params)
  rule_details = params[0]
  compile_libs = [os.path.join(rule_details[su.WDIR_CLSDEPS_KEY], '*')]
  java_namespace = tc.ThriftCommon.get_lang_namespace('java', rule_details)
  src_dir = os.path.sep.join(java_namespace.split('.'))
  java_src_files = glob.glob('%s/*.java' % src_dir)
  compile_command = jc.get_java_compile_command(
      rule_details, compile_libs, rule_details[su.JAVAC_OUTDIR_KEY],
      java_src_files, False)
  subprocess.check_call(compile_command)


class JavaThriftLibrary(tc.ThriftCommon):
  """Thrift library builder functions for Java."""
  @classmethod
  def _set_all_srcs(cls, rule_details, details_map):
    """Recursively find list of all thrift sources."""
    all_srcs = []
    for rule_symbol in rule_details[su.ALL_DEPS_KEY]:
      other_rule_details = details_map[rule_symbol]
      if su.JAVA_THRIFT_LIB_TYPE == other_rule_details[su.TYPE_KEY]:
        all_srcs.append(other_rule_details[su.SRCS_KEY][0])
    all_srcs.append(rule_details[su.SRCS_KEY][0])
    rule_details[su.ALL_SRCS_KEY] = list(set(all_srcs))

  @classmethod
  def _set_compile_deps(cls, rule_details, details_map):
    """Checks that only allowed deps are specified."""
    compile_deps = list(su.JAVA_THRIFT_JARS)
    all_deps = list(rule_details[su.ALL_DEPS_KEY])
    all_deps.extend(rule_details[su.COMPILE_DEPS_KEY])
    for rule_symbol in all_deps:
      rule = details_map[rule_symbol]
      if rule_symbol == rule_details[su.SYMBOL_KEY]:
        continue
      elif (rule[su.TYPE_KEY] == su.JAVA_THRIFT_LIB_TYPE or
            su.MAVEN_SPECS_KEY in rule):
        compile_deps.append(rule[su.OUT_KEY])
      else:
        raise su.Error('Only java thrift libs or maven libs are allowed as '
                       ' {} dependencies!'.format(su.JAVA_THRIFT_LIB_TYPE))
    rule_details[su.COMPILE_LIBS_KEY] = compile_deps

  @classmethod
  def _set_link_libs(cls, rule_details, details_map):
    """Set all java thrift lib dependencies as its compile time deps."""
    link_libs = []
    for rule_symbol in rule_details[su.ALL_DEPS_KEY]:
      other_rule_details = details_map[rule_symbol]
      if rule_symbol != rule_details[su.SYMBOL_KEY]:
        link_libs.append(other_rule_details[su.OUT_KEY])
    rule_details[su.LINK_LIBS_KEY] = link_libs

  @classmethod
  def _set_all_dep_paths(cls, rule_details):
    """Set all dependency paths."""
    all_dep_paths = rule_details[su.ALL_SRCS_KEY][:]
    all_dep_paths.extend(rule_details[su.LINK_LIBS_KEY])
    all_dep_paths.append(rule_details[su.OUT_KEY])
    rule_details[su.ALL_DEP_PATHS_KEY].extend(list(set(all_dep_paths)))

  def setup(self, rule_details, details_map):
    """Compute all dependencies and update rule_details."""
    su.init_rule_common(rule_details,
                        '{}.jar'.format(rule_details[su.NAME_KEY]),
                        [su.SRCS_KEY])
    super(JavaThriftLibrary, self).setup(rule_details, details_map)
    self._set_compile_deps(rule_details, details_map)
    su.set_workdir_child(rule_details, su.WDIR_CLSDEPS_KEY, 'clsdeps')
    su.set_workdir_child(rule_details, su.JAVAC_OUTDIR_KEY, 'javac_outdir')
    rule_details[su.POSSIBLE_PREFIXES_KEY] = su.prefix_transform([])
    self._set_all_srcs(rule_details, details_map)
    jc.JavaCommon.set_precompile_commands(rule_details)
    self._set_link_libs(rule_details, details_map)
    self._set_all_dep_paths(rule_details)

  @classmethod
  def _get_java_link_commands(cls, rule_details):
    """Get the java link commands for the generated source file."""
    command_list = []
    partial_jar = os.path.join(rule_details[su.WDIR_KEY], '.temp.jar')
    command_list.append([su.CHANGE_CURR_DIR, rule_details[su.JAVAC_OUTDIR_KEY]])
    command_list.append([su.PERFORM_JAVA_LINK_ALL_CURRDIR, partial_jar])
    link_libs = rule_details[su.LINK_LIBS_KEY][:]
    link_libs.append(partial_jar)
    command_list.append([
        su.JAVA_LINK_JAR_COMMAND, ([], [], list(set(link_libs))),
        rule_details[su.OUT_KEY], su.JAVA_FAKE_MAIN_CLASS])
    return command_list

  @classmethod
  def build_commands(cls, rule_details):
    """Generate build command line."""
    logging.info('Emitting %s at %s', rule_details[su.TYPE_KEY],
                 su.log_normalize(rule_details[su.OUT_KEY]))
    directory_list = cls._get_work_dirs(rule_details)
    directory_list.append(rule_details[su.WDIR_CLSDEPS_KEY])
    directory_list.append(rule_details[su.JAVAC_OUTDIR_KEY])
    command_list = [su.get_mkdir_command(d) for d in directory_list]
    command_list.append([su.CHANGE_CURR_DIR, rule_details[tc.SRC_CODE_DIR]])
    command_list.extend(su.cp_commands_list(rule_details, su.ALL_SRCS_KEY))
    command_list.append(tc.get_thrift_compile_command(
        rule_details, rule_details[tc.GEN_CODE_DIR]))
    command_list.append([su.CHANGE_CURR_DIR, rule_details[tc.GEN_CODE_DIR]])
    command_list.extend(rule_details[su.PRECOMPILE_COMMANDS_KEY])
    command_list.append([su.THRIFT_COMPILE_GENERATED_JAVA, rule_details])
    command_list.extend(cls._get_java_link_commands(rule_details))
    return command_list
